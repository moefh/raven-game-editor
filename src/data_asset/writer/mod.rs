mod ident_store;

use std::fs;
use std::cell::RefCell;
use std::io::{Write, Result, Error};
use std::path::Path;
use std::collections::HashMap;
use regex::Regex;
use std::sync::LazyLock;

use ident_store::{*};

use super::{StringLogger, DataAssetStore, DataAssetId, DataAssetType, AssetIdList};

static RE_UNNAMED_LOOP: LazyLock<Regex> = LazyLock::new(
    || Regex::new(r"^loop_[0-9]+$").unwrap());

struct ModSampleRef {
    mod_id: DataAssetId,
    sample_index: usize,
}

struct AnimationInfo {
    add_foot: bool,
    loop_offsets: Vec<usize>,
    loop_names: HashMap<usize,String>,
}

struct ProjectDataWriter<'a> {
    output: RefCell<String>,
    logger: RefCell<&'a mut StringLogger>,
    store: &'a DataAssetStore,
    ident: IdentStore,
    animation_info: HashMap<DataAssetId, AnimationInfo>,
}

impl<'a> ProjectDataWriter<'a> {
    pub fn new(store: &'a DataAssetStore, logger: &'a mut StringLogger) -> Self {
        ProjectDataWriter {
            output: RefCell::new(String::new()),
            logger: RefCell::new(logger),
            store,
            ident: IdentStore::new(&store.project_prefix),
            animation_info: HashMap::new(),
        }
    }

    fn write<S: AsRef<str>>(&self, data: S) {
        self.output.borrow_mut().push_str(data.as_ref());
    }

    fn log<S: AsRef<str>>(&self, msg: S) {
        self.logger.borrow_mut().log(msg);
    }

    fn write_header(&self) -> Result<()> {
        let local_time = time::OffsetDateTime::now_local();

        if let Ok(now) = local_time &&
            let Ok(datetime_format) = time::format_description::parse("[year]-[month]-[day] [hour]:[minute]:[second]") &&
            let Ok(formatted_date) = now.format(&datetime_format) {
                self.write(format!("// Auto-generated at {} by raven-game-editor\n", formatted_date));
            } else {
                self.write("// Auto-generated by raven-game-editor\n");
                self.log("WARNING: couldn't format current datetime for comment");
            }

        self.write("\n");
        self.write(format!("#define {}_DATA_VGA_SYNC_BITS {:#04x}\n", self.ident.prefix_upper, self.store.vga_sync_bits));

        if let Ok(now) = local_time &&
            let Ok(datetime_format) = time::format_description::parse("[year][month][day]00[hour][minute][second]") &&
            let Ok(formatted_date) = now.format(&datetime_format) {
                self.write(format!("#define {}_DATA_SAVE_TIMESTAMP 0x{}\n", self.ident.prefix_upper, formatted_date));
            } else {
                self.write(format!("#define {}_DATA_SAVE_TIMESTAMP 0\n", self.ident.prefix_upper));
                self.log("WARNING: couldn't format current datetime for SAVE_TIMESTAMP #define");
            }

        self.write("\n");
        self.write(format!("#if {}_DATA_BYTES\n", self.ident.prefix_upper));
        self.write("\n");
        Ok(())
    }

    fn write_data_end(&self) -> Result<()> {
        self.write(format!("#endif /* {}_DATA_BYTES */\n", self.ident.prefix_upper));
        self.write("\n");
        Ok(())
    }

    fn write_footer(&self) -> Result<()> {
        self.write(format!("// total data size: {} bytes\n", self.store.assets.data_size()));
        Ok(())
    }

    fn fix_pixel(&self, pixel: u8) -> u32 {
        ((pixel & 0x3f) | self.store.vga_sync_bits) as u32
    }

    // =========================================================================
    // === FONT
    // =========================================================================

    fn write_font_data(&self, font: &super::Font, name: &str) {
        self.write(format!("static const uint8_t {}_font_data_{}[] = {{\n", self.ident.prefix_lower, name));
        for ch in 0..super::Font::NUM_CHARS {
            self.write("  ");
            for y in 0..font.height {
                let mut byte = 0;
                for x in 0..font.width {
                    let pixel = font.data[((ch * font.height + y) * font.width + x) as usize];
                    byte |= if pixel == super::Font::FG_COLOR { 1<<(x%8) } else { 0 };
                    if x % 8 == 7 {
                        self.write(format!("{:#04x},", byte));
                        byte = 0;
                    }
                }
                if ! font.width.is_multiple_of(8) {
                    self.write(format!("{:#04x},", byte));
                }
            }
            if (ch + super::Font::FIRST_CHAR) < 127 {
                self.write(format!("  // '{}'\n", char::from_u32(ch + super::Font::FIRST_CHAR).unwrap_or('?')));
            } else {
                self.write("  // DEL\n");
            }
        }
        self.write("};\n");
        self.write("\n");
    }

    fn write_fonts(&self) -> Result<()> {
        self.write("// ================================================================\n");
        self.write("// === FONTS\n");
        self.write("// ================================================================\n");
        self.write("\n");

        for id in self.store.asset_ids.fonts.iter() {
            if let Some(font) = self.store.assets.fonts.get(id) {
                let name = self.ident.get_asset_name(DataAssetType::Font, *id)?;
                self.log(format!("-> writing font data for '{}'", name));
                self.write_font_data(font, name);
            }
        }

        self.log(format!("-> writing {} fonts", self.store.asset_ids.fonts.len()));
        self.write(format!("const struct {}_FONT {}_fonts[] = {{\n", self.ident.prefix_upper, self.ident.prefix_lower));
        for id in self.store.asset_ids.fonts.iter() {
            if let Some(font) = self.store.assets.fonts.get(id) {
                let name = self.ident.get_asset_name(DataAssetType::Font, *id)?;
                self.write(format!("  {{ {}, {}, {}_font_data_{} }},\n", font.width, font.height, self.ident.prefix_lower, name));
            }
        }
        self.write("};\n");
        self.write("\n");
        Ok(())
    }

    // =========================================================================
    // === PROP FONT
    // =========================================================================

    fn write_prop_font_data(&self, font: &super::PropFont, name: &str) -> Vec::<u16> {
        self.write(format!("static const uint8_t {}_prop_font_data_{}[] = {{\n", self.ident.prefix_lower, name));
        let mut char_offset = 0;
        let mut char_offsets = Vec::<u16>::new();
        for ch in 0..super::PropFont::NUM_CHARS {
            char_offsets.push(char_offset);
            self.write("  ");
            for y in 0..font.height {
                let width = font.char_widths[ch as usize] as u32;
                let mut byte = 0;
                for x in 0..width {
                    let pixel = font.data[((ch * font.height + y) * font.max_width + x) as usize];
                    byte |= if pixel == super::PropFont::FG_COLOR { 1<<(x%8) } else { 0 };
                    if x % 8 == 7 {
                        self.write(format!("{:#04x},", byte));
                        byte = 0;
                        char_offset += 1;
                    }
                }
                if ! width.is_multiple_of(8) {
                    self.write(format!("{:#04x},", byte));
                    char_offset += 1;
                }
            }
            if (ch + super::PropFont::FIRST_CHAR) < 127 {
                self.write(format!("  // '{}'\n", char::from_u32(ch + super::PropFont::FIRST_CHAR).unwrap_or('?')));
            } else {
                self.write("  // DEL\n");
            }
        }
        self.write("};\n");
        self.write("\n");
        char_offsets
    }

    fn write_prop_fonts(&self) -> Result<()> {
        self.write("// ================================================================\n");
        self.write("// === PROPORTIONAL FONTS\n");
        self.write("// ================================================================\n");
        self.write("\n");

        let mut font_char_offsets = HashMap::<DataAssetId, Vec<u16>>::new();
        for id in self.store.asset_ids.prop_fonts.iter() {
            if let Some(font) = self.store.assets.prop_fonts.get(id) {
                let name = self.ident.get_asset_name(DataAssetType::PropFont, *id)?;
                self.log(format!("-> writing prop font data for '{}'", name));
                let char_offsets = self.write_prop_font_data(font, name);
                font_char_offsets.insert(*id, char_offsets);
            }
        }

        self.log(format!("-> writing {} prop fonts", self.store.asset_ids.prop_fonts.len()));
        self.write(format!("const struct {}_PROP_FONT {}_prop_fonts[] = {{\n", self.ident.prefix_upper, self.ident.prefix_lower));
        for id in self.store.asset_ids.prop_fonts.iter() {
            if let Some(font) = self.store.assets.prop_fonts.get(id) {
                let name = self.ident.get_asset_name(DataAssetType::PropFont, *id)?;
                let char_offsets = font_char_offsets.get(id).ok_or_else(|| {
                    Error::other(format!("can't find char offset for pfont '{}'", id))
                })?;
                self.write("  {\n");
                self.write(format!("    {},\n", font.height));
                self.write(format!("    {}_prop_font_data_{},\n", self.ident.prefix_lower, name));
                self.write("    {  // char widths");
                for ch in 0..super::PropFont::NUM_CHARS {
                    if ch.is_multiple_of(24) { self.write("\n      "); }
                    self.write(format!("{},", font.char_widths[ch as usize]));
                }
                self.write("\n    },\n");
                self.write("    {  // char offsets");
                for ch in 0..super::PropFont::NUM_CHARS {
                    if ch.is_multiple_of(8) { self.write("\n      "); }
                    self.write(format!("{:>4},", char_offsets[ch as usize]));
                }
                self.write("\n    }\n");
                self.write("  },\n");
            }
        }
        self.write("};\n");
        self.write("\n");
        Ok(())
    }

    // =========================================================================
    // === MOD
    // =========================================================================

    fn are_mod_samples_equal(sample1: &super::ModSample, sample2: &super::ModSample) -> bool {
        if sample1.len == 0 || sample1.len != sample2.len {
            return false;
        }
        if let Some(data1) = &sample1.data && let Some(data2) = &sample2.data {
            for (s1, s2) in data1.iter().zip(data2.iter()) {
                if s1 != s2 {
                    return false;
                }
            }
            true
        } else {
            false
        }
    }

    // build the references for each
    fn get_mod_sample_refs(&self) -> HashMap<DataAssetId,Vec<ModSampleRef>> {
        let mod_ids: Vec::<DataAssetId> = self.store.asset_ids.mods.iter().copied().collect();

        let mut all_samples = HashMap::new();
        for mod_id in mod_ids.iter() {
            if let Some(mod_data) = self.store.assets.mods.get(mod_id) {
                let mut mod_samples = Vec::new();
                for (sample_index, sample) in mod_data.samples.iter().enumerate() {
                    if sample.len != 0 && sample.data.is_some() {
                        mod_samples.push(ModSampleRef { mod_id: *mod_id, sample_index });
                    }
                }
                all_samples.insert(*mod_id, mod_samples);
            }
        }

        for (mod1_index, mod1_id) in mod_ids.iter().enumerate() {
            if let Some(mod1_data) = self.store.assets.mods.get(mod1_id) {
                for (mod2_index, mod2_id) in mod_ids.iter().enumerate().skip(mod1_index+1) {
                    if let Some(mod2_data) = self.store.assets.mods.get(mod2_id) {
                        for (sample1_index, sample1) in mod1_data.samples.iter().enumerate() {
                            if sample1.len == 0 || sample1.data.is_none() { continue; }
                            for (sample2_index, sample2) in mod2_data.samples.iter().enumerate() {
                                if sample2.len == 0 || sample2.data.is_none() { continue; }
                                if Self::are_mod_samples_equal(sample1, sample2) {
                                    self.log(format!("-> merging mod samples: (mod{}:sample{}) to (mod{}:sample{})",
                                                     mod2_index+1, sample2_index+1, mod1_index+1, sample1_index+1));
                                    if let Some(mod2_samples) = all_samples.get_mut(mod2_id) {
                                        mod2_samples[sample2_index] = ModSampleRef {
                                            mod_id: *mod1_id,
                                            sample_index: sample1_index,
                                        };
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        all_samples
    }

    fn write_mod_samples_data(&self, mod_data: &super::ModData, name: &str, sample_refs: &[ModSampleRef]) {
        for (index, sample) in mod_data.samples.iter().enumerate() {
            if let Some(sample_ref) = sample_refs.get(index) {
                if sample_ref.mod_id != mod_data.asset.id || sample_ref.sample_index != index {
                    continue;  // skip this sample; it's been merged with another
                }
                if let Some(data) = &sample.data {
                    self.write(format!("static const int{}_t {}_mod_samples_{}_sample{:02}[] = {{",
                                       sample.bits_per_sample, self.ident.prefix_lower, name, index+1));
                    for (i, spl) in data.iter().enumerate() {
                        if i.is_multiple_of(16) { self.write("\n  "); }
                        if sample.bits_per_sample == 16 {
                            self.write(format!("{},", spl));
                        } else {
                            self.write(format!("{},", spl>>8));
                        }
                    }
                    self.write("\n};\n");
                    self.write("\n");
                }
            }
        }
    }

    fn write_mod_pattern(&self, mod_data: &super::ModData, name: &str) {
        self.write(format!("static const struct {}_MOD_CELL {}_mod_pattern_{}[] = {{\n",
                           self.ident.prefix_upper, self.ident.prefix_lower, name));
        let num_channels = mod_data.num_channels as usize;
        let num_patterns = mod_data.pattern.len().div_ceil(64 * num_channels);
        for pattern_num in 0..num_patterns {
            self.write(format!("  // pattern {}\n", pattern_num));
            for row in 0..64 {
                self.write("  ");
                for ch in 0..num_channels {
                    let cell_index = (64 * pattern_num + row) * num_channels + ch;
                    if cell_index >= mod_data.pattern.len() { break; }
                    let cell = mod_data.pattern[cell_index];
                    let note_index = if cell.period == 0 {
                        0xff
                    } else {
                        let (note, octave) = super::ModData::get_period_note(cell.period);
                        if note < 0 || octave < 0 { 0xff } else { note + octave * 12 }
                    };
                    self.write(format!("{{ {:>2}, {:#04x}, {:#05x}, }}, ", cell.sample, note_index, cell.effect));
                }
                self.write("\n");
            }
        }
        self.write("};\n");
        self.write("\n");
    }

    fn write_mod_samples(&self, mod_data: &super::ModData, sample_refs: &[ModSampleRef]) -> Result<()> {
        for (index, sample) in mod_data.samples.iter().enumerate() {
            self.write(format!("      {{{:>6},{:>6},{:>6}, {:#04x}, {:>2}, {:>2},",
                               sample.len, sample.loop_start, sample.loop_len,
                               if sample.finetune < 0 { sample.finetune + 16 } else { sample.finetune },
                               sample.volume, sample.bits_per_sample));
            if sample.len == 0 || sample.data.is_none() {
                self.write(" { .data = NULL }, },\n");
                continue;
            }
            if let Some(sample_ref) = sample_refs.get(index) {
                let sample_ref_mod_name = self.ident.get_asset_name(DataAssetType::ModData, sample_ref.mod_id)?;
                self.write(format!(" {{ .data{} = {}_mod_samples_{}_sample{:02} }}, }},\n",
                                   sample.bits_per_sample, self.ident.prefix_lower,
                                   sample_ref_mod_name, sample_ref.sample_index+1));
            }
        }
        Ok(())
    }

    fn write_mods(&self) -> Result<()> {
        self.write("// ================================================================\n");
        self.write("// === MOD\n");
        self.write("// ================================================================\n");
        self.write("\n");

        // samples
        let mod_sample_refs = self.get_mod_sample_refs();
        for id in self.store.asset_ids.mods.iter() {
            if let Some(mod_data) = self.store.assets.mods.get(id) {
                let name = self.ident.get_asset_name(DataAssetType::ModData, *id)?;
                let sample_refs = mod_sample_refs.get(id).ok_or_else(|| {
                    Error::other(format!("can't find sample refs for mod {}", id))
                })?;
                self.write_mod_samples_data(mod_data, name, sample_refs);
            }
        }

        // patterns
        for id in self.store.asset_ids.mods.iter() {
            if let Some(mod_data) = self.store.assets.mods.get(id) {
                let name = self.ident.get_asset_name(DataAssetType::ModData, *id)?;
                self.write_mod_pattern(mod_data, name);
            }
        }

        // mods
        self.log(format!("-> writing {} mods", self.store.asset_ids.mods.len()));
        self.write(format!("const struct {}_MOD_DATA {}_mods[] = {{\n", self.ident.prefix_upper, self.ident.prefix_lower));
        for id in self.store.asset_ids.mods.iter() {
            if let Some(mod_data) = self.store.assets.mods.get(id) {
                let name = self.ident.get_asset_name(DataAssetType::ModData, *id)?;
                self.write("  {\n");
                self.write("    // samples:\n");
                self.write("    {\n");
                if let Some(sample_refs) = mod_sample_refs.get(id) {
                    self.write_mod_samples(mod_data, sample_refs)?;
                }
                self.write("    },\n");
                self.write("    // num channels:\n");
                self.write(format!("    {},\n", mod_data.num_channels));
                self.write("    // song positions:\n");
                self.write(format!("    {}, {{", mod_data.song_positions.len()));
                for (index, song_pos) in mod_data.song_positions.iter().enumerate() {
                    if index.is_multiple_of(16) { self.write("\n      "); }
                    self.write(format!("{:>3},", song_pos));
                }
                self.write("\n");
                self.write("    },\n");
                self.write("    // pattern:\n");
                self.write(format!("    {}, {}_mod_pattern_{},\n",
                                   mod_data.pattern.len().div_ceil(64*mod_data.num_channels as usize),
                                   self.ident.prefix_lower, name));
                self.write("  },\n");
            }
        }
        self.write("};\n");
        self.write("\n");

        Ok(())
    }

    // =========================================================================
    // === SFX
    // =========================================================================

    fn write_sfx_data(&self, sfx: &super::Sfx, name: &str) {
        self.write(format!("static const int{}_t {}_sfx_samples_{}[] = {{",
                           sfx.bits_per_sample, self.ident.prefix_lower, name));
        for (i, spl) in sfx.samples.iter().enumerate() {
            if i.is_multiple_of(16) { self.write("\n  "); }
            if sfx.bits_per_sample == 16 {
                self.write(format!("{},", spl));
            } else {
                self.write(format!("{},", spl>>8));
            }
        }
        self.write("\n};\n");
        self.write("\n");
    }

    fn write_sfxs(&self) -> Result<()> {
        self.write("// ================================================================\n");
        self.write("// === SFX\n");
        self.write("// ================================================================\n");
        self.write("\n");

        for id in self.store.asset_ids.sfxs.iter() {
            if let Some(sfx) = self.store.assets.sfxs.get(id) {
                let name = self.ident.get_asset_name(DataAssetType::Sfx, *id)?;
                self.write_sfx_data(sfx, name);
            }
        }

        self.log(format!("-> writing {} sfxs", self.store.asset_ids.sfxs.len()));
        self.write(format!("const struct {}_SFX {}_sfxs[] = {{\n", self.ident.prefix_upper, self.ident.prefix_lower));
        for id in self.store.asset_ids.sfxs.iter() {
            if let Some(sfx) = self.store.assets.sfxs.get(id) {
                let name = self.ident.get_asset_name(DataAssetType::Sfx, *id)?;
                self.write(format!("  {{{:>6},{:>5},{:>5}, {}, {{ .spl{} = {}_sfx_samples_{} }} }},\n",
                                   sfx.len, sfx.loop_start, sfx.loop_len, sfx.bits_per_sample,
                                   sfx.bits_per_sample, self.ident.prefix_lower, name));
            }
        }
        self.write("};\n");
        self.write("\n");

        Ok(())
    }

    // =========================================================================
    // === TILESET
    // =========================================================================

    fn write_tileset_data(&self, tileset: &super::Tileset, name: &str) {
        self.write(format!("static const uint32_t {}_tileset_data_{}[] = {{\n",
                           self.ident.prefix_lower, name));

        let empty_pixel = self.store.vga_sync_bits as u32;
        let empty_quad = empty_pixel | empty_pixel << 8 | empty_pixel << 16 | empty_pixel << 24;

        let width = tileset.width as usize;
        let height = tileset.height as usize;
        let num_tiles = tileset.num_tiles as usize;
        let stride = width.div_ceil(4);
        for tile_num in 0..num_tiles {
            self.write(format!("  // tile {}", tile_num));
            for y in 0..height {
                for s in 0..stride {
                    if (y*stride + s).is_multiple_of(8) { self.write("\n  "); }
                    let index = ((tile_num * height) + y) * width + s*4;
                    let mut quad = empty_quad | self.fix_pixel(tileset.data[index]);
                    if width > s*4+1 { quad |= (self.fix_pixel(tileset.data[index+1])) <<  8; }
                    if width > s*4+2 { quad |= (self.fix_pixel(tileset.data[index+2])) << 16; }
                    if width > s*4+3 { quad |= (self.fix_pixel(tileset.data[index+3])) << 24; }
                    self.write(format!("{:#10x},", quad));
                }
            }
            self.write("\n");
        }
        self.write("};\n");
        self.write("\n");
    }

    fn write_tilesets(&self) -> Result<()> {
        self.write("// ================================================================\n");
        self.write("// === TILESETS\n");
        self.write("// ================================================================\n");
        self.write("\n");

        for id in self.store.asset_ids.tilesets.iter() {
            if let Some(tileset) = self.store.assets.tilesets.get(id) {
                let name = self.ident.get_asset_name(DataAssetType::Tileset, *id)?;
                self.write_tileset_data(tileset, name);
            }
        }

        self.log(format!("-> writing {} tilesets", self.store.asset_ids.tilesets.len()));
        self.write(format!("const struct {}_IMAGE {}_tilesets[] = {{\n", self.ident.prefix_upper, self.ident.prefix_lower));
        for id in self.store.asset_ids.tilesets.iter() {
            if let Some(tileset) = self.store.assets.tilesets.get(id) {
                let name = self.ident.get_asset_name(DataAssetType::Tileset, *id)?;
                self.write(format!("  {{ {}, {}, {}, {}, {}_tileset_data_{} }},\n",
                                   tileset.width, tileset.height, tileset.width.div_ceil(4), tileset.num_tiles,
                                   self.ident.prefix_lower, name));
            }
        }
        self.write("};\n");
        self.write("\n");
        Ok(())
    }

    // =========================================================================
    // === SPRITE
    // =========================================================================

    fn copy_image_row(dest: &mut [u8], src: &[u8], mirror: bool) {
        if mirror {
            for (d, s) in dest.iter_mut().zip(src.iter().rev()) {
                *d = *s;
            }
        } else {
            for (d, s) in dest.iter_mut().zip(src.iter()) {
                *d = *s;
            }
        }
    }

    fn write_sprite_frames(&self, sprite: &super::Sprite, mirror: bool) {
        let empty_pixel = self.store.vga_sync_bits as u32;
        let empty_quad = empty_pixel | empty_pixel << 8 | empty_pixel << 16 | empty_pixel << 24;
        let width = sprite.width as usize;
        let height = sprite.height as usize;
        let num_frames = sprite.num_frames as usize;
        let stride = width.div_ceil(4);
        let mut image_row = vec![self.store.vga_sync_bits; width];
        for frame_num in 0..num_frames {
            self.write(format!("  // frame {}{}", frame_num, if mirror { " (mirror)" } else { "" }));
            for y in 0..height {
                let index = (frame_num * height + y) * width;
                Self::copy_image_row(&mut image_row, &sprite.data[index..index+width], mirror);
                for s in 0..stride {
                    if s.is_multiple_of(8) { self.write("\n  "); }
                    let mut quad = empty_quad | self.fix_pixel(image_row[s*4]);
                    if width > s*4+1 { quad |= (self.fix_pixel(image_row[s*4 + 1])) <<  8; }
                    if width > s*4+2 { quad |= (self.fix_pixel(image_row[s*4 + 2])) << 16; }
                    if width > s*4+3 { quad |= (self.fix_pixel(image_row[s*4 + 3])) << 24; }
                    self.write(format!("{:#10x},", quad));
                }
            }
            self.write("\n");
        }
    }

    fn write_sprite_data(&self, sprite: &super::Sprite, name: &str) {
        self.write(format!("static const uint32_t {}_sprite_data_{}[] = {{\n",
                           self.ident.prefix_lower, name));
        self.write_sprite_frames(sprite, false);
        if super::Sprite::MIRROR_FRAMES {
            self.write_sprite_frames(sprite, true);
        }
        self.write("};\n");
        self.write("\n");
    }

    fn write_sprites(&self) -> Result<()> {
        self.write("// ================================================================\n");
        self.write("// === SPRITES\n");
        self.write("// ================================================================\n");
        self.write("\n");

        for id in self.store.asset_ids.sprites.iter() {
            if let Some(sprite) = self.store.assets.sprites.get(id) {
                let name = self.ident.get_asset_name(DataAssetType::Sprite, *id)?;
                self.write_sprite_data(sprite, name);
            }
        }

        self.log(format!("-> writing {} sprites", self.store.asset_ids.sprites.len()));
        let mult_mirrors = if super::Sprite::MIRROR_FRAMES { 2 } else { 1 };
        self.write(format!("const struct {}_IMAGE {}_sprites[] = {{\n", self.ident.prefix_upper, self.ident.prefix_lower));
        for id in self.store.asset_ids.sprites.iter() {
            if let Some(sprite) = self.store.assets.sprites.get(id) {
                let name = self.ident.get_asset_name(DataAssetType::Sprite, *id)?;
                self.write(format!("  {{ {}, {}, {}, {}, {}_sprite_data_{} }},\n",
                                   sprite.width, sprite.height, sprite.width.div_ceil(4), sprite.num_frames * mult_mirrors,
                                   self.ident.prefix_lower, name));
            }
        }
        self.write("};\n");
        self.write("\n");

        Ok(())
    }

    // =========================================================================
    // === MAP
    // =========================================================================

    fn write_map_tiles(&self, tiles: &[u8]) {
        for (index, tile) in tiles.iter().enumerate() {
            if index.is_multiple_of(16) { self.write("\n  "); }
            self.write(format!("{:#04x},", tile))
        }
    }

    fn write_map_data(&self, map_data: &super::MapData, name: &str) {
        self.write(format!("static const uint8_t {}_map_tiles_{}[] = {{", self.ident.prefix_lower, name));
        self.write("\n  // foreground");
        self.write_map_tiles(&map_data.fg_tiles);
        self.write("\n  // collision");
        self.write_map_tiles(&map_data.clip_tiles);
        self.write("\n  // effects");
        self.write_map_tiles(&map_data.fx_tiles);
        self.write("\n  // background");
        self.write_map_tiles(&map_data.bg_tiles);
        self.write("\n};\n");
        self.write("\n");
    }

    fn write_maps(&self) -> Result<()> {
        self.write("// ================================================================\n");
        self.write("// === MAPS\n");
        self.write("// ================================================================\n");
        self.write("\n");

        for id in self.store.asset_ids.maps.iter() {
            if let Some(map_data) = self.store.assets.maps.get(id) {
                let name = self.ident.get_asset_name(DataAssetType::MapData, *id)?;
                self.write_map_data(map_data, name);
            }
        }

        self.log(format!("-> writing {} maps", self.store.asset_ids.maps.len()));
        self.write(format!("const struct {}_MAP {}_maps[] = {{\n", self.ident.prefix_upper, self.ident.prefix_lower));
        for id in self.store.asset_ids.maps.iter() {
            if let Some(map_data) = self.store.assets.maps.get(id) {
                let name = self.ident.get_asset_name(DataAssetType::MapData, *id)?;
                let tileset_index = self.ident.get_asset_index(DataAssetType::Tileset, map_data.tileset_id)?;
                self.write(format!("  {{ {}, {}, {}, {}, &{}_tilesets[{}], {}_map_tiles_{} }},\n",
                                   map_data.width, map_data.height, map_data.bg_width, map_data.bg_height,
                                   self.ident.prefix_lower, tileset_index,
                                   self.ident.prefix_lower, name));
            }
        }
        self.write("};\n");
        self.write("\n");

        Ok(())
    }

    // =========================================================================
    // === SPRITE ANIMATION
    // =========================================================================

    fn write_animation_frames(&self, anim: &super::SpriteAnimation, name: &str) -> AnimationInfo {
        let add_foot = anim.loops.iter().any(|l| l.frame_indices.iter().any(|f| f.foot_index.is_some()));
        let mut loop_offsets = Vec::new();
        let mut loop_names = HashMap::new();

        self.write(format!("static const uint8_t {}_sprite_animation_frames_{}[] = {{\n",
                           self.ident.prefix_lower, name));
        let mut offset = 0;
        for (loop_index, aloop) in anim.loops.iter().enumerate() {
            let use_loop_name = if aloop.name == "names" { "names0" } else { &aloop.name };
            IdentStore::add_unique_name(loop_index, use_loop_name, &mut loop_names);
            if aloop.frame_indices.len() == 0 { continue; }
            self.write(format!("  // {}\n  ", aloop.name));
            for frame in aloop.frame_indices.iter() {
                self.write(format!("{:#04x},", frame.head_index.unwrap_or(0xff)));
                if add_foot {
                    self.write(format!("{:#04x},", frame.foot_index.unwrap_or(0xff)));
                }
            }
            self.write("\n");
            loop_offsets.push(offset);
            offset += aloop.frame_indices.len() * if add_foot { 2 } else { 1 };
        }
        self.write("};\n");
        self.write("\n");

        AnimationInfo {
            add_foot,
            loop_offsets,
            loop_names,
        }
    }

    fn write_sprite_animations(&mut self) -> Result<()> {
        self.write("// ================================================================\n");
        self.write("// === SPRITE ANIMATIONS\n");
        self.write("// ================================================================\n");
        self.write("\n");

        //let mut info = HashMap::new();
        for id in self.store.asset_ids.animations.iter() {
            if let Some(anim) = self.store.assets.animations.get(id) {
                let name = self.ident.get_asset_name(DataAssetType::SpriteAnimation, *id)?;
                //info.insert(*id, self.write_animation_frames(anim, name));
                self.animation_info.insert(*id, self.write_animation_frames(anim, name));
            }
        }

        self.log(format!("-> writing {} animations", self.store.asset_ids.animations.len()));
        self.write(format!("const struct {}_SPRITE_ANIMATION {}_sprite_animations[] = {{\n",
                           self.ident.prefix_upper, self.ident.prefix_lower));
        for id in self.store.asset_ids.animations.iter() {
            if let Some(anim) = self.store.assets.animations.get(id) {
                let name = self.ident.get_asset_name(DataAssetType::SpriteAnimation, *id)?;
                let sprite_index = self.ident.get_asset_index(DataAssetType::Sprite, anim.sprite_id)?;
                let info = self.animation_info.get(id).ok_or_else(|| {
                    Error::other(format!("can't find info for animation {}", id))
                })?;
                self.write("  {\n");
                self.write(format!("    {}_sprite_animation_frames_{},\n", self.ident.prefix_lower, name));
                self.write(format!("    &raven_sprites[{}],\n", sprite_index));
                self.write(format!("    {{ {}, {}, {}, {} }},\n", anim.clip_rect.x, anim.clip_rect.y, anim.clip_rect.w, anim.clip_rect.h));
                self.write(format!("    {},\n", if info.add_foot { 1 } else { 0 }));
                self.write(format!("    {},\n", anim.foot_overlap));
                self.write("    {\n");
                let mut last_offset = 0;
                for (loop_index, aloop) in anim.loops.iter().enumerate() {
                    let loop_name = info.loop_names.get(&loop_index).ok_or_else(|| {
                        Error::other(format!("can't find loop name {} for animation {}", loop_index, id))
                    })?;
                    let loop_offset = info.loop_offsets.get(loop_index).copied().unwrap_or(last_offset);
                    if aloop.frame_indices.len() > 0 {
                        self.write(format!("      {{ {:>5}, {:>5} }}, // {}\n", loop_offset, aloop.frame_indices.len(), loop_name));
                    } else {
                        self.write(format!("      {{ {:>5}, {:>5} }},\n", loop_offset, aloop.frame_indices.len()));
                    }
                    last_offset = loop_offset + aloop.frame_indices.len();
                }
                self.write("    }\n");
                self.write("  },\n");
            }
        }
        self.write("};\n");
        self.write("\n");

        Ok(())
    }

    fn write_animation_names(&self) -> Result<()> {
        self.write("// ================================================================\n");
        self.write("// === SPRITE ANIMATION LOOP NAMES\n");
        self.write("// ================================================================\n");
        self.write("\n");

        for id in self.store.asset_ids.animations.iter() {
            if let Some(anim) = self.store.assets.animations.get(id) {
                let name = self.ident.get_asset_name(DataAssetType::SpriteAnimation, *id)?;
                let info = self.animation_info.get(id).ok_or_else(|| {
                    Error::other(format!("error reading loop names for animation {}", id))
                })?;
                let name_upper = name.to_ascii_uppercase();
                let mut num_named_loops = 0;
                for loop_index in (0..anim.loops.len()).rev() {
                    let loop_name = info.loop_names.get(&loop_index).ok_or_else(|| {
                        Error::other(format!("error reading name for loop {} of animation {}", loop_index, id))
                    })?;
                    if ! RE_UNNAMED_LOOP.is_match(&loop_name) {
                        num_named_loops = loop_index + 1;
                        break;
                    }
                }
                if num_named_loops == 0 { continue; }

                self.write(format!("enum {}_SPRITE_ANIMATION_{}_LOOP_NAMES {{\n", self.ident.prefix_upper, name_upper));
                for loop_index in 0..num_named_loops {
                    let loop_name = info.loop_names.get(&loop_index).ok_or_else(|| {
                        Error::other(format!("error reading name for loop {} of animation {}", loop_index, id))
                    })?;
                    let loop_name_upper = loop_name.to_ascii_uppercase();
                    self.write(format!("  {}_SPRITE_ANIMATION_{}_LOOP_{},\n", self.ident.prefix_upper, name_upper, loop_name_upper));
                }
                self.write("};\n");
                self.write("\n");
            }
        }

        Ok(())
    }

    // =========================================================================
    // === ROOM
    // =========================================================================

    fn write_room_maps(&self, room: &super::Room, name: &str) -> Result<()> {
        self.write(format!("static const struct {}_ROOM_MAP_INFO {}_room_maps_{}[] = {{\n",
                           self.ident.prefix_upper, self.ident.prefix_lower, name));
        for room_map in room.maps.iter() {
            let map_index = self.ident.get_asset_index(DataAssetType::MapData, room_map.map_id)?;
            self.write(format!("  {{ {}, {}, &{}_maps[{}] }},\n", room_map.x, room_map.y, self.ident.prefix_lower, map_index));
        }
        self.write("};\n");
        self.write("\n");

        Ok(())
    }

    fn write_room_entities(&self, room: &super::Room, name: &str) -> Result<()> {
        self.write(format!("static const struct {}_ROOM_ENTITY_INFO {}_room_entities_{}[] = {{\n",
                           self.ident.prefix_upper, self.ident.prefix_lower, name));
        for ent in room.entities.iter() {
            let anim_index = self.ident.get_asset_index(DataAssetType::SpriteAnimation, ent.animation_id)?;
            self.write(format!("  {{ {}, {}, &{}_sprite_animations[{}], {}, {}, {}, {} }},\n",
                               ent.x, ent.y, self.ident.prefix_lower, anim_index,
                               ent.data0, ent.data1, ent.data2, ent.data3));
        }
        self.write("};\n");
        self.write("\n");

        Ok(())
    }

    fn write_room_triggers(&self, room: &super::Room, name: &str) {
        self.write(format!("static const struct {}_ROOM_TRIGGER_INFO {}_room_triggers_{}[] = {{\n",
                           self.ident.prefix_upper, self.ident.prefix_lower, name));
        for trg in room.triggers.iter() {
            self.write(format!("  {{ {}, {}, {}, {}, {}, {}, {}, {} }},\n",
                               trg.x, trg.y, trg.width, trg.height, trg.data0, trg.data1, trg.data2, trg.data3));
        }
        self.write("};\n");
        self.write("\n");
    }

    fn write_rooms(&self) -> Result<()> {
        self.write("// ================================================================\n");
        self.write("// === ROOMS\n");
        self.write("// ================================================================\n");
        self.write("\n");

        for id in self.store.asset_ids.rooms.iter() {
            if let Some(room) = self.store.assets.rooms.get(id) {
                let name = self.ident.get_asset_name(DataAssetType::Room, *id)?;
                self.write_room_maps(room, name)?;
                self.write_room_entities(room, name)?;
                self.write_room_triggers(room, name);
            }
        }

        self.log(format!("-> writing {} rooms", self.store.asset_ids.rooms.len()));
        self.write(format!("const struct {}_ROOM {}_rooms[] = {{\n",
                           self.ident.prefix_upper, self.ident.prefix_lower));
        for id in self.store.asset_ids.rooms.iter() {
            if let Some(room) = self.store.assets.rooms.get(id) {
                let name = self.ident.get_asset_name(DataAssetType::Room, *id)?;
                self.write(format!("  {{ {}, {}, {}, {}_room_maps_{}, {}_room_entities_{}, {}_room_triggers_{} }},\n",
                                   room.maps.len(), room.entities.len(), room.triggers.len(),
                                   self.ident.prefix_lower, name, self.ident.prefix_lower, name, self.ident.prefix_lower, name));
            }
        }
        self.write("};\n");
        self.write("\n");

        Ok(())
    }

    fn write_room_entity_names(&self, room: &super::Room, name_upper: &str) -> Result<()> {
        let mut namespace = HashMap::new();

        self.write(format!("enum {}_ROOM_{}_ENT_NAMES {{\n", self.ident.prefix_upper, name_upper));
        for (index, ent) in room.entities.iter().enumerate() {
            let use_name = if ent.name == "names" { "names0" } else { &ent.name };
            IdentStore::add_unique_name(index, use_name, &mut namespace);
            let ent_name = namespace.get(&index).ok_or_else(|| {
                Error::other(format!("error reading name of entity {} room {}", index, room.asset.id))
            })?;
            self.write(format!("  {}_ROOM_{}_ENT_{},\n", self.ident.prefix_upper, name_upper, &ent_name.to_ascii_uppercase()));
        }
        self.write("};\n");
        self.write("\n");

        Ok(())
    }

    fn write_room_trigger_names(&self, room: &super::Room, name_upper: &str) -> Result<()> {
        let mut namespace = HashMap::new();

        self.write(format!("enum {}_ROOM_{}_TRG_NAMES {{\n", self.ident.prefix_upper, name_upper));
        for (index, trg) in room.triggers.iter().enumerate() {
            let use_name = if trg.name == "names" { "names0" } else { &trg.name };
            IdentStore::add_unique_name(index, use_name, &mut namespace);
            let trg_name = namespace.get(&index).ok_or_else(|| {
                Error::other(format!("error reading name of trigger {} room {}", index, room.asset.id))
            })?;
            self.write(format!("  {}_ROOM_{}_TRG_{},\n", self.ident.prefix_upper, name_upper, &trg_name.to_ascii_uppercase()));
        }
        self.write("};\n");
        self.write("\n");

        Ok(())
    }

    fn write_room_item_names(&self) -> Result<()> {
        self.write("// ================================================================\n");
        self.write("// === ROOM ITEM NAMES\n");
        self.write("// ================================================================\n");
        self.write("\n");

        for id in self.store.asset_ids.rooms.iter() {
            if let Some(room) = self.store.assets.rooms.get(id) {
                let name = self.ident.get_asset_name(DataAssetType::Room, *id)?;
                let name_upper = name.to_ascii_uppercase();
                self.write_room_entity_names(room, &name_upper)?;
                self.write_room_trigger_names(room, &name_upper)?;
            }
        }

        Ok(())
    }

    // =========================================================================
    // === ASSET IDS
    // =========================================================================

    fn write_asset_ids_for(&self, asset_ids: &AssetIdList, asset_type: DataAssetType, type_name: &str) -> Result<()> {
        self.write(format!("enum {}_{}_IDS {{\n", self.ident.prefix_upper, type_name));
        for id in asset_ids.iter() {
            let name = self.ident.get_asset_name(asset_type, *id)?;
            let name_upper = name.to_ascii_uppercase();
            self.write(format!("  {}_{}_ID_{},\n", self.ident.prefix_upper, type_name, name_upper));
        }
        self.write(format!("  {}_{}_COUNT,\n", self.ident.prefix_upper, type_name));

        self.write("};\n");
        self.write("\n");

        Ok(())
    }

    fn write_asset_ids(&self) -> Result<()> {
        self.write("// ================================================================\n");
        self.write("// === IDS\n");
        self.write("// ================================================================\n");
        self.write("\n");

        self.write_asset_ids_for(&self.store.asset_ids.fonts, DataAssetType::Font, "FONT")?;
        self.write_asset_ids_for(&self.store.asset_ids.prop_fonts, DataAssetType::PropFont, "PROP_FONT")?;
        self.write_asset_ids_for(&self.store.asset_ids.mods, DataAssetType::ModData, "MOD")?;
        self.write_asset_ids_for(&self.store.asset_ids.sfxs, DataAssetType::Sfx, "SFX")?;
        self.write_asset_ids_for(&self.store.asset_ids.tilesets, DataAssetType::Tileset, "TILESET")?;
        self.write_asset_ids_for(&self.store.asset_ids.sprites, DataAssetType::Sprite, "SPRITE")?;
        self.write_asset_ids_for(&self.store.asset_ids.maps, DataAssetType::MapData, "MAP")?;
        self.write_asset_ids_for(&self.store.asset_ids.animations, DataAssetType::SpriteAnimation, "SPRITE_ANIMATION")?;
        self.write_asset_ids_for(&self.store.asset_ids.rooms, DataAssetType::Room, "ROOM")?;

        Ok(())
    }

    // =========================================================================
    // === PROJECT
    // =========================================================================

    fn gen_unique_asset_names(&mut self) -> Result<()> {
        self.ident.add_assets(DataAssetType::Tileset, self.store);
        self.ident.add_assets(DataAssetType::MapData, self.store);
        self.ident.add_assets(DataAssetType::Room, self.store);
        self.ident.add_assets(DataAssetType::Sprite, self.store);
        self.ident.add_assets(DataAssetType::SpriteAnimation, self.store);
        self.ident.add_assets(DataAssetType::Sfx, self.store);
        self.ident.add_assets(DataAssetType::ModData, self.store);
        self.ident.add_assets(DataAssetType::Font, self.store);
        self.ident.add_assets(DataAssetType::PropFont, self.store);
        Ok(())
    }

    pub fn write_project(&mut self) -> Result<()> {
        self.gen_unique_asset_names()?;
        self.write_header()?;

        self.write_fonts()?;
        self.write_prop_fonts()?;
        self.write_mods()?;
        self.write_sfxs()?;
        self.write_tilesets()?;
        self.write_sprites()?;
        self.write_maps()?;
        self.write_sprite_animations()?;
        self.write_rooms()?;

        self.write_data_end()?;

        self.write_animation_names()?;
        self.write_room_item_names()?;
        self.write_asset_ids()?;

        self.write_footer()?;
        Ok(())
    }
}

fn write_file(filename: &Path, data: &str) -> Result<()> {
    fn write_tmp(filename: &Path, data: &str) -> Result<()> {
        let mut file = fs::File::create(filename)?;
        file.write_all(data.as_bytes())?;
        file.sync_all()
    }

    let tmp_filename = filename.with_extension("h-tmp");
    match write_tmp(&tmp_filename, data) {
        Ok(_) => fs::rename(&tmp_filename, filename),
        Err(e) => {
            let _ = fs::remove_file(tmp_filename); // we don't really care about this error
            Err(e)
        }
    }
}

pub fn write_project<P: AsRef<Path>>(filename: P, store: &DataAssetStore, logger: &mut StringLogger) -> Result<()> {
    logger.log("-> saving project");

    let mut writer = ProjectDataWriter::new(store, logger);
    match writer.write_project() {
        Ok(()) => {},
        Err(e) => {
            logger.log(format!("ERROR: {}", e));
            return Err(e);
        }
    };

    match write_file(filename.as_ref(), &writer.output.borrow()) {
        Ok(()) => {
            logger.log(format!("DONE: project saved to {}", filename.as_ref().display()));
            Ok(())
        }
        Err(e) => {
            logger.log(format!("ERROR writing file {}:\n{}", filename.as_ref().display(), e));
            Err(e)
        }
    }
}
